# PHPのプロセス/スレッド処理のパフォーマンステスト

## 目的
単純かつ大量な処理において、通常/マルチプロセス/マルチスレッドで、  
どのようにパフォーマンスが変化するか調査します。

## 要件
* OS  
  Windows NT系または*nix系(たぶんMacでも動くと思います)  

* PHPのバージョン  
  PHP5（Windows7において5.4.31、CentOS6.6において5.6.7で動作確認済み）  
  php.iniのmemory_limitは処理によって大きくする必要があります。  
  マルチスレッドで動かすには、pthreadsモジュールを入れる必要があります。  
  http://qiita.com/rana_kualu/items/02f380f2f3d5020051bb  
  なお、*nixの場合は、ZTSが有効になっている必要があります。  
  yum installで入れたPHPの場合、ZTSは無効です。  
  http://fd0.hatenablog.jp/entry/2012/10/18/232827

## ロジック
各ワーカーにおいて、  
現在日時に乱数を加えた文字列を100回SHA1ハッシュ化の処理を  
任意の数(main.php実行時の第1引数)こなしtmpファイルに出力します。  
最終的にtmpファイルが任意の数(main.php実行時の第2引数)に達したら、  
順番通りにtmpファイルの内容をtxtファイルに結合します。  
例えば15000処理 * 4ワーカーの場合、  
100 * 15000 * 4で600万回SHA1ハッシュ化を行います。

## 使い方
マルチプロセスの場合は、src/worker_processディレクトリに  
マルチスレッドの場合は、src/worker_threadディレクトリに  
カレントディレクトリを変更してください。

第1引数を1ワーカーあたりの処理数、第2引数をワーカー数として  
次のようにmain.phpを実行してください。  
php -f main.php 15000 4

完了すると以下のファイルが生成されます。  
* main\_第1引数\_第2引数.log  
  マイクロ秒まで含む、各ワーカー開始/終了日時、  
  最終的なtxtファイル出力終了日時が記録されたログファイル。

* output\_第1引数\_第2引数.txt 
  各行にSHA1ハッシュ化された文字列が記録されたファイル。

パフォーマンステストが目的なので、重要なのはログファイルの方です。  
処理時間は、最終行の日時 - 1行目の日時で求められます。

## 結果
次の環境でテストしました。  
* Windows NT系の環境
  OS: Windows 7 Home Premium 64ビット  
  CPU: Core i7-2677M 1.80GHz 2コア 4スレッド  
  メモリ: 4GB  
  ストレージ: SSD  
  PHP: 5.4.31 pthreads有効 memory_limit=128M

* *nix系の環境
  OS: CentOS6.6  
  CPU: Xeon E5-2650 v2 2.60GHz 3コア 6スレッド  
  メモリ: 2GB  
  ストレージ: SSD  
  PHP: 5.6.7 memory_limit=128M

resultの配下に、各テストのログファイルがあります。

* Windows NT系マルチプロセスの結果
  60000 * 1プロセス: 00:02:03.156  
  30000 * 2プロセス: 00:01:15.554  
  20000 * 3プロセス: 00:01:06.275  
  15000 * 4プロセス: 00:01:05.004  
  10000 * 6プロセス: 00:01:08.465  
  5000 * 12プロセス: 00:01:06.315  

* Windows NT系マルチスレッドの結果
  60000 * 1スレッド: 00:02:03.139  
  30000 * 2スレッド: 00:01:23.285  
  20000 * 3スレッド: 00:01:45.063  
  15000 * 4スレッド: 00:01:45.541  
  10000 * 6スレッド: 00:01:46.571  
  5000 * 12スレッド: 00:01:49.745  

* *nix系マルチプロセスの結果
  60000 * 1プロセス: 00:00:08.697  
  30000 * 2プロセス: 00:00:04.652  
  20000 * 3プロセス: 00:00:03.055  
  15000 * 4プロセス: 00:00:03.351  
  10000 * 6プロセス: 00:00:03.334  
  5000 * 12プロセス: 00:00:03.275  

* *nix系マルチスレッドの結果 
  実行するサーバに運用中のサイトがあったため、  
  ZTSを有効化したPHPをビルドしテストすることは控えました。

* 結論
  マルチプロセスでならCPUのコア数で同時実行すると良いでしょう。  
  スレッド数で同時実行すると更に早く終わる可能性もあります。
  
  マルチスレッドでの同時実行は、  
  *nixの場合、ZTS有効化したPHPをビルドする必要がありハードルが高いです。  
  Windowsの場合でも、マルチプロセスに比べて遅かったです。
  
  いずれにしても、どのワーカーから開始/終了するか分からない前提で  
  コーディングしなければならない点に注意が必要です。  
  例えば、ワーカーが吐いた一時ファイルから順番通りに結合する必要がある場合は、  
  一時ファイルに番号をふる、一時ファイルの総数がワーカー数と一致するか判定する、  
  といった工夫が必要になります。  
  ロールバックがあり得るバッチ処理の場合だと、特に複雑になりそうです・。；
  
  **PHPでも並列処理は有効！**
